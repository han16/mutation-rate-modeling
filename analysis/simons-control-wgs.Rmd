---
title: "Simons control WGS"
output: html_document
---


```{r, echo=F, message=F, warning=F}
rm(list=ls())
library(tidyverse)
library(gridExtra)
library(ggpubr)
set.seed(123)
```


```{r, echo=F}
loadRData <- function(fileName){
#loads an RData file, and returns it
    load(fileName)
    get(ls()[ls() != "fileName"])
}
```

## Mutation count partition by mutation types 

WGS Simons control data: 516 idiopathic autism families (2,064 individuals)

index    | mutation type | \# mutations
----|-------|-------|---
1 | A->C (+ T->G) | 3,899+3,900=7,799
2 | A->G (+ T->C) | 15,083+14,919=30,002  
3 | A->T (+ T->A) | 3,664+3,743=7,407
4 | C->G (+ G->C) | 5,393+5,308=10,701
5 | C->T (+ G->A) | 23,977+23,907=47,884 
6 | C->A (+ G->T)| 5,404+5,652=11,056

```{r, echo=F}
slices <- c(7799, 30002, 7404, 10701, 47884, 11056) 
lbls <- c("A->C", "A->G", "A->T", "C->G", "C->T", "C->A")
pct <- round(slices/sum(slices)*100)
lbls <- paste(lbls, pct) # add percents to labels 
lbls <- paste(lbls,"%",sep="") # ad % to labels 
pie(slices,labels = lbls, col=rainbow(length(lbls)),
  	main="Percentage of mutation types in Simons control data ")
```


## Model evaluation

We consider the following  models, 

* Model 0 (M0): 3-mer only  for 9 mutation types. This is implemented by enforcing all parameters to be zero in M1.  

* Model 1 (M1): 3-mer+features for pooled 9 mutation types 
* Model M1(CpG+nonCpG): split Model 1 (M1) into two submodels, M1(CpG):3-mer+features for pooled 3 CpG mutation types and M1(nonCpG): 3-mer+features for pooled 6 nonCpG mutation types  

* Model 2 (M2): 3-mer+features for 9 mutation types

### Predictive density measure 

* Whole human genome (hg19) is evenly split into 100bp windows 
* use even (odd) windows as training data to estimate parameters $\beta$
* use another half odd (even) windows as validation data to make prediction 
* windows with predicted density as `NaN` due to $\widehat{\mu}_j=0$ are removed 
* M0 uses scale parameters to calculate predicted rate 
* Overall these two models are comparable to each other, none of which outperforms another across all mutation types. For some mutation types, M0 works better and for others, M2 is better.  

#### M0 vs M2 by mutation types 

```{r, echo=F}
path="C:/Shengtong/Research/mutation-rate/mutation-rate-modeling/data/post.predictive.density"
m0.post.pred=tibble()
m2.post.pred=tibble()
m2.post.pred=as_tibble(read.table(paste(path, "post.pred.for.model.txt", sep="/"), header=T))
m0.post.pred=as_tibble(read.table(paste(path, "post.pred.for.model.with.zero.coefficient.and.intercept.txt", sep="/"), header=T))
m0.m2.combine=bind_rows(m0.post.pred, m2.post.pred)%>%add_column(model=c(rep("M0", 18), rep("M2", 18)))
m0.m2.combine$mutation.type=m0.m2.combine$mutation.type %>% recode( mutation.C_to_A.CpG.and.mutation.G_to_T.CpG="C_to_A.CpG", mutation.C_to_G.CpG.and.mutation.G_to_C.CpG="C_to_G.CpG", mutation.C_to_T.CpG.and.mutation.G_to_A.CpG="C_to_T.CpG", mutation.C_to_A.nonCpG.and.mutation.G_to_T.nonCpG="C_to_A.nonCpG",        mutation.C_to_G.nonCpG.and.mutation.G_to_C.nonCpG="C_to_G.noncpG,", mutation.C_to_T.nonCpG.and.mutation.G_to_A.nonCpG="C_to_T.nonCpG",                       mutation.A_to_C.and.mutation.T_to_G="A_to_C",  mutation.A_to_G.and.mutation.T_to_C="A_to_G", mutation.A_to_T.and.mutation.T_to_A="A_to_T") # rename mutation type to make them shorter

################## plot them 

ggplot(data=m0.m2.combine%>%filter(train.set=="odd"), aes(x=mutation.type, y=-post.pred, fill=model)) +
   theme(axis.text.x = element_text(angle = 60, vjust = 0.5, size=10))+
theme(text = element_text(size=10))+
geom_bar(stat="identity", position=position_dodge())+
   ylab("-log(pred.prob)")+
   ggtitle("odd widow as train set and even as validation")+
  theme(plot.title = element_text(hjust = 0.5, size=10)) # center the title

ggplot(data=m0.m2.combine%>%filter(train.set=="even"), aes(x=mutation.type, y=-post.pred, fill=model)) +
   theme(axis.text.x = element_text(angle = 60, vjust = 0.5, size=10))+
theme(text = element_text(size=10))+
geom_bar(stat="identity", position=position_dodge())+
    ylab("-log(pred.prob)")+
   ggtitle("even widow as train set and odd as validation")+
  theme(plot.title = element_text(hjust = 0.5, size=10)) # center the title
```

#### Predicted probability of different models 

* In M0, M2 for each one of  9 mutation types, use even(odd) window as train set to estimate parameters, and use remaining odd(even) window to calculate predicted probability, and sum up across all mutation types. 

* In M1, use odd(even) window as train set, and remaining even(odd) window to calculate predicted probability and add them up. 

* Split 9 mutation types into 3 CpG combined sample, M1(CpG) and 6 nonCpG combined sample, M1(nonCpG)  

* the higher predicted probability, the better, M1>M1(CpG)+M1(nonCpG)>M0>M2



```{r, echo=F}
m1.post.pred=as_tibble(read.table(paste(path, "pooled.mutation.type.log.predictive.density.txt", sep="/"), header=T))
m1.CpG.post.pred=as_tibble(read.table(paste(path, "pooled.CpG.mutation.type.data.log.predictive.density.txt", sep="/"), header=T))
m1.nonCpG.post.pred=as_tibble(read.table(paste(path, "pooled.nonCpG.mutation.type.data.log.predictive.density.txt", sep="/"), header=T))
pp0=m0.post.pred%>%select(post.pred)%>%summarise(sum=sum(post.pred))%>%pull()
pp1=m1.post.pred%>%select(post.pred)%>%summarise(sum=sum(post.pred))%>%pull()
pp1.CpG=m1.CpG.post.pred%>%select(post.pred)%>%summarise(sum=sum(post.pred))%>%pull()
pp1.nonCpG=m1.nonCpG.post.pred%>%select(post.pred)%>%summarise(sum=sum(post.pred))%>%pull()
pp2=m2.post.pred%>%select(post.pred)%>%summarise(sum=sum(post.pred))%>%pull()  
total.post.pred=tibble(model=c("M0", "M1", "M1(CpG+nonCpG)", "M2"), post.pred=c(pp0, pp1, (pp1.CpG+pp1.nonCpG), pp2))

ggplot(data=total.post.pred, aes(x=model, y=-post.pred)) +
   theme(axis.text.x = element_text(angle = 60, vjust = 0.5, size=10))+
theme(text = element_text(size=10))+
geom_bar(stat="identity", fill="blue")+
    ylab("-log(pred.prob)")+
   #ggtitle("even widow as train set and odd as validation")+
  theme(plot.title = element_text(hjust = 0.5, size=10)) # center the title
```

### Expected rate vs observed rate 

#### Mutation type combined sample 


* this analysis is for combined sample, regardless of mutation types 
* 100kb and 1Mb windows are considered by summing over the results from 100 bp windows 
* exp in M0 is expected rate adjusted by scaling parameter $L=\frac{\sum y_i}{\sum \mu_i}$
* MSE are calculated as $\sum(obs-exp)^2/No.windows$
* no points seem obvious to be outlier in the plot of 1Mb windows 

```{r, echo=F, message=F, warning=F}
path="C:/Shengtong/Research/mutation-rate/ObsvsExp.1m.window/"
#######################################################
prefix="table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.ExpObsVar"
suffix0="window.as.train.with.zero.coefficient.and.intercept.bed.bed.added.1m"
m0.exp.obs.even=read.table(paste(path, prefix, ".even.", suffix0, sep="")) # this is for mo 
m0.exp.obs.odd=read.table(paste(path, prefix, ".odd.", suffix0, sep=""))
m0.exp.obs.even.obs=as.numeric(as.character(m0.exp.obs.even$V4)); m0.exp.obs.even.obs[is.na(m0.exp.obs.even.obs)]=0
m0.exp.obs.even.exp=as.numeric(as.character(m0.exp.obs.even$V5)); m0.exp.obs.even.exp[is.na(m0.exp.obs.even.exp)]=0
m0.exp.obs.odd.obs=as.numeric(as.character(m0.exp.obs.odd$V4)); m0.exp.obs.odd.obs[is.na(m0.exp.obs.odd.obs)]=0
m0.exp.obs.odd.exp=as.numeric(as.character(m0.exp.obs.odd$V5)); m0.exp.obs.odd.exp[is.na(m0.exp.obs.odd.exp)]=0
m0.exp.obs.adj=sum(m0.exp.obs.even.obs+m0.exp.obs.odd.obs)/sum(m0.exp.obs.even.exp+m0.exp.obs.odd.exp)*(m0.exp.obs.even.exp+m0.exp.obs.odd.exp)  # use scaled rate 
m0.exp.obs=cbind((m0.exp.obs.even.obs+m0.exp.obs.odd.obs), m0.exp.obs.adj)
colnames(m0.exp.obs)=c("obs", "exp")

#####################################################
suffix1="window.as.train.bed.bed.added.1m"
m1.exp.obs.even=read.table(paste(path, prefix, ".even.", suffix1, sep="")) # this is for m1
m1.exp.obs.odd=read.table(paste(path, prefix, ".odd.", suffix1, sep=""))
m1.exp.obs.even.obs=as.numeric(as.character(m1.exp.obs.even$V4)); m1.exp.obs.even.obs[is.na(m1.exp.obs.even.obs)]=0
m1.exp.obs.even.exp=as.numeric(as.character(m1.exp.obs.even$V5)); m1.exp.obs.even.exp[is.na(m1.exp.obs.even.exp)]=0
m1.exp.obs.odd.obs=as.numeric(as.character(m1.exp.obs.odd$V4)); m1.exp.obs.odd.obs[is.na(m1.exp.obs.odd.obs)]=0
m1.exp.obs.odd.exp=as.numeric(as.character(m1.exp.obs.odd$V5)); m1.exp.obs.odd.exp[is.na(m1.exp.obs.odd.exp)]=0
m1.exp.obs=cbind((m1.exp.obs.even.obs+m1.exp.obs.odd.obs), (m1.exp.obs.even.exp+m1.exp.obs.odd.exp))
colnames(m1.exp.obs)=c("obs", "exp")

############################################
prefix="table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.3CpG.combined.ExpObsVar"
suffix1="window.as.train.bed.bed.added.1m"
m1.CpG.exp.obs.even=read.table(paste(path, prefix, ".even.", suffix1, sep="")) # this is for m1 for combined CpG
m1.CpG.exp.obs.odd=read.table(paste(path, prefix, ".odd.", suffix1, sep=""))
m1.CpG.exp.obs.even.obs=as.numeric(as.character(m1.CpG.exp.obs.even$V4)); m1.CpG.exp.obs.even.obs[is.na(m1.CpG.exp.obs.even.obs)]=0
m1.CpG.exp.obs.even.exp=as.numeric(as.character(m1.CpG.exp.obs.even$V5)); m1.CpG.exp.obs.even.exp[is.na(m1.CpG.exp.obs.even.exp)]=0
m1.CpG.exp.obs.odd.obs=as.numeric(as.character(m1.CpG.exp.obs.odd$V4)); m1.CpG.exp.obs.odd.obs[is.na(m1.CpG.exp.obs.odd.obs)]=0
m1.CpG.exp.obs.odd.exp=as.numeric(as.character(m1.CpG.exp.obs.odd$V5)); m1.CpG.exp.obs.odd.exp[is.na(m1.CpG.exp.obs.odd.exp)]=0
m1.CpG.exp.obs=cbind((m1.CpG.exp.obs.even.obs+m1.CpG.exp.obs.odd.obs), (m1.CpG.exp.obs.even.exp+m1.CpG.exp.obs.odd.exp))
colnames(m1.CpG.exp.obs)=c("obs", "exp")


############################################
prefix="table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.6nonCpG.combined.ExpObsVar"
suffix1="window.as.train.bed.bed.added.1m"
m1.nonCpG.exp.obs.even=read.table(paste(path, prefix, ".even.", suffix1, sep="")) # this is for m1 for combined nonCpG
m1.nonCpG.exp.obs.odd=read.table(paste(path, prefix, ".odd.", suffix1, sep=""))
m1.nonCpG.exp.obs.even.obs=as.numeric(as.character(m1.nonCpG.exp.obs.even$V4)); m1.nonCpG.exp.obs.even.obs[is.na(m1.nonCpG.exp.obs.even.obs)]=0
m1.nonCpG.exp.obs.even.exp=as.numeric(as.character(m1.nonCpG.exp.obs.even$V5)); m1.nonCpG.exp.obs.even.exp[is.na(m1.nonCpG.exp.obs.even.exp)]=0
m1.nonCpG.exp.obs.odd.obs=as.numeric(as.character(m1.nonCpG.exp.obs.odd$V4)); m1.nonCpG.exp.obs.odd.obs[is.na(m1.nonCpG.exp.obs.odd.obs)]=0
m1.nonCpG.exp.obs.odd.exp=as.numeric(as.character(m1.nonCpG.exp.obs.odd$V5)); m1.nonCpG.exp.obs.odd.exp[is.na(m1.nonCpG.exp.obs.odd.exp)]=0
m1.nonCpG.exp.obs=cbind((m1.nonCpG.exp.obs.even.obs+m1.nonCpG.exp.obs.odd.obs), (m1.nonCpG.exp.obs.even.exp+m1.nonCpG.exp.obs.odd.exp))
colnames(m1.nonCpG.exp.obs)=c("obs", "exp")

#######################################################
prefix="table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.3CpG.combined.ExpObsVar"
m0.CpG.exp.obs.even=read.table(paste(path, prefix, ".even.", suffix0, sep="")) # this is for mo for CpG combined 
m0.CpG.exp.obs.odd=read.table(paste(path, prefix, ".odd.", suffix0, sep=""))
m0.CpG.exp.obs.even.obs=as.numeric(as.character(m0.CpG.exp.obs.even$V4)); m0.CpG.exp.obs.even.obs[is.na(m0.CpG.exp.obs.even.obs)]=0
m0.CpG.exp.obs.even.exp=as.numeric(as.character(m0.CpG.exp.obs.even$V5)); m0.CpG.exp.obs.even.exp[is.na(m0.CpG.exp.obs.even.exp)]=0
m0.CpG.exp.obs.odd.obs=as.numeric(as.character(m0.CpG.exp.obs.odd$V4)); m0.CpG.exp.obs.odd.obs[is.na(m0.CpG.exp.obs.odd.obs)]=0
m0.CpG.exp.obs.odd.exp=as.numeric(as.character(m0.CpG.exp.obs.odd$V5)); m0.CpG.exp.obs.odd.exp[is.na(m0.CpG.exp.obs.odd.exp)]=0
m0.CpG.exp.obs.adj=sum(m0.CpG.exp.obs.even.obs+m0.CpG.exp.obs.odd.obs)/sum(m0.CpG.exp.obs.even.exp+m0.CpG.exp.obs.odd.exp)*(m0.CpG.exp.obs.even.exp+m0.CpG.exp.obs.odd.exp)  # use scaled rate 
m0.CpG.exp.obs=cbind((m0.CpG.exp.obs.even.obs+m0.CpG.exp.obs.odd.obs), m0.CpG.exp.obs.adj)
colnames(m0.CpG.exp.obs)=c("obs", "exp")

#######################################################
prefix="table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.6nonCpG.combined.ExpObsVar"
m0.nonCpG.exp.obs.even=read.table(paste(path, prefix, ".even.", suffix0, sep="")) # this is for mo for CpG combined 
m0.nonCpG.exp.obs.odd=read.table(paste(path, prefix, ".odd.", suffix0, sep=""))
m0.nonCpG.exp.obs.even.obs=as.numeric(as.character(m0.nonCpG.exp.obs.even$V4)); m0.nonCpG.exp.obs.even.obs[is.na(m0.nonCpG.exp.obs.even.obs)]=0
m0.nonCpG.exp.obs.even.exp=as.numeric(as.character(m0.nonCpG.exp.obs.even$V5)); m0.nonCpG.exp.obs.even.exp[is.na(m0.nonCpG.exp.obs.even.exp)]=0
m0.nonCpG.exp.obs.odd.obs=as.numeric(as.character(m0.nonCpG.exp.obs.odd$V4)); m0.nonCpG.exp.obs.odd.obs[is.na(m0.nonCpG.exp.obs.odd.obs)]=0
m0.nonCpG.exp.obs.odd.exp=as.numeric(as.character(m0.nonCpG.exp.obs.odd$V5)); m0.nonCpG.exp.obs.odd.exp[is.na(m0.nonCpG.exp.obs.odd.exp)]=0
m0.nonCpG.exp.obs.adj=sum(m0.nonCpG.exp.obs.even.obs+m0.nonCpG.exp.obs.odd.obs)/sum(m0.nonCpG.exp.obs.even.exp+m0.nonCpG.exp.obs.odd.exp)*(m0.nonCpG.exp.obs.even.exp+m0.nonCpG.exp.obs.odd.exp)  # use scaled rate 
m0.nonCpG.exp.obs=cbind((m0.nonCpG.exp.obs.even.obs+m0.nonCpG.exp.obs.odd.obs), m0.nonCpG.exp.obs.adj)
colnames(m0.nonCpG.exp.obs)=c("obs", "exp")

##########################
m0.m1.exp.obs=tibble(obs=c(m0.exp.obs[,1], m1.exp.obs[,1]), exp=c(m0.exp.obs[,2], m1.exp.obs[,2]), model=c(rep("M0", nrow(m0.exp.obs)), rep("M1", nrow(m1.exp.obs))))

y.limit=max(m0.m1.exp.obs[,1:2])
x.limit=y.limit
ggplot(m0.m1.exp.obs, aes(x=exp, y=obs, color=model)) +
  geom_point()+
  # xlim(c(0, x.limit))+ylim(c(0, y.limit))+
   geom_abline(intercept = 0, slope = 1)+
   ggtitle("scatter plot of 1Mb windows; MSE: M0>M1")+
   theme(plot.title = element_text(hjust = 0.5, size=10)) # center the title
#######
#MSE:Mo: 
obs.exp=m0.m1.exp.obs%>%filter(model=="M0")
cat("M0 has MSE of", sum((obs.exp$obs-obs.exp$exp)^2)/nrow(obs.exp), "\n")

obs.exp=m0.m1.exp.obs%>%filter(model=="M1")
cat("M1 has MSE of", sum((obs.exp$obs-obs.exp$exp)^2)/nrow(obs.exp), "\n")
```


* M1(CpG+nonCpG) has one outlier, which is removed in scatter plot 

```{r, echo=F, message=F, warning=F}
###########################################
#m0.m1.m0CpGnonCpG.m1.CpCnonCpG.exp.obs=tibble(obs=c(m0.exp.obs[,1], m1.exp.obs[,1], (m0.CpG.exp.obs[,1]+m0.nonCpG.exp.obs[,1]), (m1.CpG.exp.obs[,1]+m1.nonCpG.exp.obs[,1])), exp=c(m0.exp.obs[,2], m1.exp.obs[,2], (m0.CpG.exp.obs[,2]+m0.nonCpG.exp.obs[,2]), (m1.CpG.exp.obs[,2]+m1.nonCpG.exp.obs[,2])), model=c(rep("M0", nrow(m0.exp.obs)), rep("M1", nrow(m1.exp.obs)), rep("M0(CpG+nonCpG)", nrow(m0.CpG.exp.obs)), rep("M1(CpG+nonCpG)", nrow(m1.CpG.exp.obs))))

#### exclude m0CpGnonCpG
m0.m1.m1CpCnonCpG.exp.obs=tibble(obs=c(m0.exp.obs[,1], m1.exp.obs[,1], (m1.CpG.exp.obs[,1]+m1.nonCpG.exp.obs[,1])), exp=c(m0.exp.obs[,2], m1.exp.obs[,2], (m1.CpG.exp.obs[,2]+m1.nonCpG.exp.obs[,2])), model=c(rep("M0", nrow(m0.exp.obs)), rep("M1", nrow(m1.exp.obs)), rep("M1(CpG+nonCpG)", nrow(m1.CpG.exp.obs))))

y.limit=max(m0.m1.m1CpCnonCpG.exp.obs[,1:2])
x.limit=y.limit

### remove the outlier in m1CpGnonCpG
outlier=which.max((m1.CpG.exp.obs+m1.nonCpG.exp.obs)[,2])
outlier.index=c(outlier, outlier+nrow(m0.exp.obs),  outlier+2*nrow(m0.exp.obs))

ggplot(m0.m1.m1CpCnonCpG.exp.obs[-c(outlier.index),], aes(x=exp, y=obs, color=model)) +
  geom_point()+
  # xlim(c(0, x.limit))+ylim(c(0, y.limit))+
   geom_abline(intercept = 0, slope = 1)+
   ggtitle("scatter plot of 1Mb windows")+
   theme(plot.title = element_text(hjust = 0.5, size=10)) # center the title
#######
#MSE:Mo: 
obs.exp=m0.m1.m1CpCnonCpG.exp.obs[-c(outlier.index),]%>%filter(model=="M0")
cat("After removing one outlier, M0 has MSE of", sum((obs.exp$obs-obs.exp$exp)^2)/nrow(obs.exp), "\n")

obs.exp=m0.m1.m1CpCnonCpG.exp.obs[-c(outlier.index),]%>%filter(model=="M1")
cat("After removing one outlier, M1 has MSE of", sum((obs.exp$obs-obs.exp$exp)^2)/nrow(obs.exp), "\n")

#obs.exp=m0.m1.m1CpCnonCpG.exp.obs%>%filter(model=="M0(CpG+nonCpG)")
#cat("M0(CpG+nonCpG) has MSE of", sum((obs.exp$obs-obs.exp$exp)^2)/nrow(obs.exp), "\n")

obs.exp=m0.m1.m1CpCnonCpG.exp.obs[-c(outlier.index),]%>%filter(model=="M1(CpG+nonCpG)")
cat("After removing one outlier, M1(CpG+nonCpG) has MSE of", sum((obs.exp$obs-obs.exp$exp)^2)/nrow(obs.exp), "\n")
```


```{r, echo=F, message=F, warning=F}
path="C:/Shengtong/Research/mutation-rate/ObsvsExp.100k.window/"
prefix="table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.ExpObsVar"
suffix0="window.as.train.with.zero.coefficient.and.intercept.bed.bed.added.100k"
m0.exp.obs.even=read.table(paste(path, prefix, ".even.", suffix0, sep="")) # this is for mo 
m0.exp.obs.odd=read.table(paste(path, prefix, ".odd.", suffix0, sep=""))
m0.exp.obs.even.obs=as.numeric(as.character(m0.exp.obs.even$V4)); m0.exp.obs.even.obs[is.na(m0.exp.obs.even.obs)]=0
m0.exp.obs.even.exp=as.numeric(as.character(m0.exp.obs.even$V5)); m0.exp.obs.even.exp[is.na(m0.exp.obs.even.exp)]=0
m0.exp.obs.odd.obs=as.numeric(as.character(m0.exp.obs.odd$V4)); m0.exp.obs.odd.obs[is.na(m0.exp.obs.odd.obs)]=0
m0.exp.obs.odd.exp=as.numeric(as.character(m0.exp.obs.odd$V5)); m0.exp.obs.odd.exp[is.na(m0.exp.obs.odd.exp)]=0
m0.exp.obs.adj=sum(m0.exp.obs.even.obs+m0.exp.obs.odd.obs)/sum(m0.exp.obs.even.exp+m0.exp.obs.odd.exp)*(m0.exp.obs.even.exp+m0.exp.obs.odd.exp)  # use scaled rate 
m0.exp.obs=cbind((m0.exp.obs.even.obs+m0.exp.obs.odd.obs), m0.exp.obs.adj)
colnames(m0.exp.obs)=c("obs", "exp")

suffix1="window.as.train.bed.bed.added.100k"
m1.exp.obs.even=read.table(paste(path, prefix, ".even.", suffix1, sep="")) # this is for m1
m1.exp.obs.odd=read.table(paste(path, prefix, ".odd.", suffix1, sep=""))
m1.exp.obs.even.obs=as.numeric(as.character(m1.exp.obs.even$V4)); m1.exp.obs.even.obs[is.na(m1.exp.obs.even.obs)]=0
m1.exp.obs.even.exp=as.numeric(as.character(m1.exp.obs.even$V5)); m1.exp.obs.even.exp[is.na(m1.exp.obs.even.exp)]=0
m1.exp.obs.odd.obs=as.numeric(as.character(m1.exp.obs.odd$V4)); m1.exp.obs.odd.obs[is.na(m1.exp.obs.odd.obs)]=0
m1.exp.obs.odd.exp=as.numeric(as.character(m1.exp.obs.odd$V5)); m1.exp.obs.odd.exp[is.na(m1.exp.obs.odd.exp)]=0
m1.exp.obs=cbind((m1.exp.obs.even.obs+m1.exp.obs.odd.obs), (m1.exp.obs.even.exp+m1.exp.obs.odd.exp))
colnames(m1.exp.obs)=c("obs", "exp")
m0.m1.exp.obs=tibble(obs=c(m0.exp.obs[,1], m1.exp.obs[,1]), exp=c(m0.exp.obs[,2], m1.exp.obs[,2]), model=c(rep("M0", nrow(m0.exp.obs)), rep("M1", nrow(m1.exp.obs))))

y.limit=max(m0.m1.exp.obs[,1:2])
x.limit=y.limit
ggplot(m0.m1.exp.obs, aes(x=exp, y=obs, color=model)) +
  geom_point()+
  # xlim(c(0, x.limit))+ylim(c(0, y.limit))+
   geom_abline(intercept = 0, slope = 1)+
   ggtitle("scatter plot of 100kb windows; MSE: MSE.M0=4.69<M1=4.75")+
   theme(plot.title = element_text(hjust = 0.5, size=10)) # center the title
MSE.m0=sum((m0.exp.obs[,1]-m0.exp.obs[,2])^2)/nrow(m0.exp.obs)
MSE.m1=sum((m1.exp.obs[,1]-m1.exp.obs[,2])^2)/nrow(m1.exp.obs)

```

* there is one outlier in the plot of M1 




```{r, echo=F, message=F, warning=F}
outlier.index=which.max(m1.exp.obs[,2])
m0.m1.exp.obs=m0.m1.exp.obs[-c(outlier.index, nrow(m0.exp.obs)+outlier.index),]  # remove the outliers 
y.limit=max(m0.m1.exp.obs[,1:2])
x.limit=y.limit
ggplot(m0.m1.exp.obs, aes(x=exp, y=obs, color=model)) +
  geom_point()+
  # xlim(c(0, x.limit))+ylim(c(0, y.limit))+
   geom_abline(intercept = 0, slope = 1)+
   ggtitle("scatter plot of 100kb windows; MSE: MSE.M0=4.699>M1=4.696")+
   theme(plot.title = element_text(hjust = 0.5, size=10)) # center the title
MSE.m0=sum((m0.exp.obs[-outlier.index,1]-m0.exp.obs[-outlier.index,2])^2)/(nrow(m0.exp.obs)-1)
MSE.m1=sum((m1.exp.obs[-outlier.index,1]-m1.exp.obs[-outlier.index,2])^2)/(nrow(m1.exp.obs)-1)
```





#### M0 vs M2 by adding up all mutation types 


* each dot is one 100kb window by summing up 100bp windows 
* For each one of 9 mutation types, use odd(even) windows to estimate parameters, calculate expected rate in the same odd (even) window  and sum up over all mutation types. 
* exp in M0 is expected rate adjusted by scaling parameter $L=\frac{\sum y_i}{\sum \mu_i}$


```{r, echo=F, message=F, warning=F, cache=T, eval=T}
########### consider windows of 100k bps  
path="C:/Shengtong/Research/mutation-rate/ObsvsExp.100k.window"
mutation.type=unique(as.character(read.table("C:/Shengtong/Research/mutation-rate/mutation-rate-modeling/data/post.predictive.density/post.pred.for.model.txt", header=T)$mutation.type)) # get mutation types 
Train=c("odd", "even")
m2.exp.obs.list=list()
k=0
m0.exp.obs.total=tibble(obs=rep(0, 31063), exp=rep(0,31063)) # store total count across all mutation types 
m2.exp.obs.total=tibble(obs=rep(0, 31063), exp=rep(0, 31063))
for (mut in 1:length(mutation.type))
   for (set in 1:length(Train))
   {
#      mut=1; set=1
      k=k+1
#      cat(mutation.type[mut], "is running", "\n")
      m2.exp.obs=as_tibble(read.table(paste(path, "/", "table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_", mutation.type[mut], ".ExpObsVar.", Train[set], ".window.as.train.bed.bed.added.100k", sep=""), header=F))
      m2.exp.obs.list[[k]]=m2.exp.obs
      m2.exp.obs.vec1=as.numeric(as.character(m2.exp.obs$V4))
      m2.exp.obs.vec1[is.na(m2.exp.obs.vec1)]=0  ## fill NA with zero 
      m2.exp.obs.total$obs=m2.exp.obs.total$obs+m2.exp.obs.vec1
      
      m2.exp.obs.vec2=as.numeric(as.character(m2.exp.obs$V5))
      m2.exp.obs.vec2[is.na(m2.exp.obs.vec2)]=0  ## fill NA with zero 
      m2.exp.obs.total$exp=m2.exp.obs.total$exp+m2.exp.obs.vec2
      
      m0.exp.obs=as_tibble(read.table(paste(path, "/", "table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_", mutation.type[mut], ".ExpObsVar.", Train[set], ".window.as.train.with.zero.coefficient.and.intercept.bed.bed.added.100k", sep=""), header=F))
      m0.exp.obs.vec1=as.numeric(as.character(m0.exp.obs$V4))
      m0.exp.obs.vec1[is.na(m0.exp.obs.vec1)]=0  ## fill NA with zero 
      m0.exp.obs.total$obs=m0.exp.obs.total$obs+m0.exp.obs.vec1
      
      m0.exp.obs.vec2=as.numeric(as.character(m0.exp.obs$V5))
      m0.exp.obs.vec2[is.na(m0.exp.obs.vec2)]=0  ## fill NA with zero 
      m0.exp.obs.total$exp=m0.exp.obs.total$exp+m0.exp.obs.vec2
      
   } # end of for (mut in 1:length(mutation.type))

scale.para=sum(m0.exp.obs.total$obs)/sum(m0.exp.obs.total$exp)
m0.exp.obs.total=m0.exp.obs.total%>%add_column(scaled.exp=scale.para*m0.exp.obs.total$exp)
m0.exp.obs.total=m0.exp.obs.total[,-2]
m0.exp.obs.total=m0.exp.obs.total%>%rename(exp=scaled.exp) # rename col names 
######################### plot M0: use scale parameter to adjust expected rate  
ggplot(m0.exp.obs.total, aes(x=exp, y=obs)) +
  geom_point()+
   xlim(c(0, max(m0.exp.obs.total)))+ylim(c(0, max(m0.exp.obs.total)))+
   geom_abline(intercept = 0, slope = 1)+
   xlab("expected rate")+ylab("observed rate")+
   ggtitle("M0")+
   theme(plot.title = element_text(hjust = 0.5, size=10)) # center the title
######################### plot M2  
ggplot(m2.exp.obs.total, aes(x=exp, y=obs)) +
  geom_point()+
   xlim(c(0,max(m2.exp.obs.total[,1:2]) ))+
ylim(c(0, max(m2.exp.obs.total[,1:2])))+
   geom_abline(intercept = 0, slope = 1)+
   xlab("expected rate")+ylab("observed rate")+
   ggtitle("M2")+
   theme(plot.title = element_text(hjust = 0.5, size=10)) # center the title

m2.exp.obs.total.nooutlier=m2.exp.obs.total%>%filter(exp<1000)
ggplot(m2.exp.obs.total.nooutlier, aes(x=exp, y=obs)) +
  geom_point()+
   xlim(c(0, max(m2.exp.obs.total.nooutlier)))+ylim(c(0,max(m2.exp.obs.total.nooutlier)))+
   geom_abline(intercept = 0, slope = 1)+
   xlab("expected rate")+ylab("observed rate")+
   ggtitle("M2 without outlier")+
   theme(plot.title = element_text(hjust = 0.5, size=10)) # center the title
############################


m0.m2.exp.obs.total=rbind(m0.exp.obs.total, m2.exp.obs.total) %>% add_column(model=c(rep("M0", nrow(m0.exp.obs.total)), rep("M2", nrow(m2.exp.obs.total))))  # combine two models together 

y.limit=max(m0.m2.exp.obs.total[,1:2])
x.limit=y.limit
ggplot(m0.m2.exp.obs.total, aes(x=exp, y=obs, color=model)) +
  geom_point()+
  # xlim(c(0, x.limit))+ylim(c(0, y.limit))+
   geom_abline(intercept = 0, slope = 1)+
  # ggtitle(paste(mutation.type[ceiling(i/2)]))+
   theme(plot.title = element_text(hjust = 0.5, size=7)) # center the title


m0.m2.exp.obs.total.nooutlier=m0.m2.exp.obs.total%>%filter(exp<1000)
y.limit=max(m0.m2.exp.obs.total.nooutlier[,1:2])
x.limit=y.limit
ggplot(m0.m2.exp.obs.total.nooutlier, aes(x=exp, y=obs, color=model)) +
  geom_point()+
  # xlim(c(0, x.limit))+ylim(c(0, y.limit))+
   geom_abline(intercept = 0, slope = 1)+
   ggtitle("Removing the outlier driven by high recombination rate")+
   theme(plot.title = element_text(hjust = 0.5, size=10)) # center the title

######## save and output the results 
#write.table(m0.exp.obs.total, file=paste(path, "/","m0.exp.obs.total.txt", sep=""))
#write.table(m2.exp.obs.total, file=paste(path, "/","m2.exp.obs.total.txt", sep=""))
#save(m0.m2.exp.obs.chr.list, file=paste(path, "/", "m0.m2.exp.obs.chr.list.RData", sep=""))
```


#### Outlier diagnostic 



Note: In a few windows, the calculated expected rate could be unexpected high due to big recombination rate in several windows, such as 108.8. 

Look at mutation type `mutation.A_to_C` at chromosome 8 as an example.  

* recombination rate in those windows and across all windows 

```
 awk '$11>100' table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.A_to_C.chr8.ERVbaseline.1DHS.2CpGisland.3lamin.4gc.5reptime.6RecombRate.7Exon.8H3K27ac.9H3K27me3.10H3K36me3.11H3K4me1.12H3K4me3.13H3K9ac.14H3K9me3.even.line
chr8     139247700       139247800       0       5.8508268e-08   0       0       1       0.41    .       108.804         0 0       1       0       0       0       0       1
chr8     139247900       139248000       0       3.7592286e-08   0       0       1       0.59    .       108.804         0 0       1       0       0       0       0       1
chr8     139248100       139248200       0       4.8498557e-08   0       0       1       0.44    .       108.804         0 0       1       0       0       0       0       1

```
there are 50 such windows in total and 50 in complementary strand `mutation.T_to_G`. 

Those 50 windows have recombination rate (RR) of `108.804`, more than 100 times high than average RR across all windows of 0.84. 

```
awk '{sum+=$11} END {print sum}' table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.A_to_C.chr8.ERVbaseline.1DHS.2CpGisland.3lamin.4gc.5reptime.6RecombRate.7Exon.8H3K27ac.9H3K27me3.10H3K36me3.11H3K4me1.12H3K4me3.13H3K9ac.14H3K9me3.even.line
615910

wc -l  table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.A_to_C.chr8.ERVbaseline.1DHS.2CpGisland.3lamin.4gc.5reptime.6RecombRate.7Exon.8H3K27ac.9H3K27me3.10H3K36me3.11H3K4me1.12H3K4me3.13H3K9ac.14H3K9me3.even.line
731820 table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.A_to_C.chr8.ERVbaseline.1DHS.2CpGisland.3lamin.4gc.5reptime.6RecombRate.7Exon.8H3K27ac.9H3K27me3.10H3K36me3.11H3K4me1.12H3K4me3.13H3K9ac.14H3K9me3.even.line

> 615910/731820
[1] 0.8416141

```

* predicted rate in those windows and across all windows 

all those 50 windows have predicted rate more than 0.5 

```
awk '$5>0.5' table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.A_to_C.and.mutation.T_to_G.ExpObsVar.even.window.as.train.bed
chr8 139247700 139247800 0 0.885879142920415 0.000179683336383749 3927.62074039213 -0.941211529317621 0.826701765213676
chr8 139247900 139248000 0 0.514188561224198 0.000103058730615795 2306.96721407905 -0.717069425665464 0.763334370034514
chr8 139248100 139248200 0 0.814619465876907 0.000164902137512123 3618.84938902892 -0.902562721298031 0.816620990462835
chr8 139248300 139248400 0 0.845005809651171 0.000171279641853248 3748.88094484896 -0.919241975570726 0.821015489926893
chr8 139248500 139248600 0 0.851571372578056 0.000173296884058543 3763.06476062817 -0.922806248666564 0.821945908060196


awk '$5>0.5' table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.A_to_C.and.mutation.T_to_G.ExpObsVar.even.window.as.train.bed | wc -l
50
```


however M0 gives predicted rate  

```
grep 'chr8' table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.A_to_C.and.mutation.T_to_G.ExpObsVar.even.window.as.train.with.zero.coefficient.and.intercept.bed | awk '$2>=139247700 &&  $2<=139257500'
chr8 139247700 139247800 0 1.00172949e-07 0.000179683336383749 3927.62074039213 -0.000316501104263476 0.500126265670176
chr8 139247900 139248000 0 5.868529e-08 0.000103058730615795 2306.96721407905 -0.000242250469555788 0.500096643953808
chr8 139248100 139248200 0 9.225769e-08 0.000164902137512123 3618.84938902892 -0.000303739510106934 0.500121174530947
chr8 139248300 139248400 0 9.5600379e-08 0.000171279641853248 3748.88094484896 -0.000309193109560999 0.500123350202247
chr8 139248500 139248600 0 9.6045573e-08 0.000173296884058543 3763.06476062817 -0.000309912202083106 0.500123637078644

grep 'chr8' table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.A_to_C.and.mutation.T_to_G.ExpObsVar.even.window.as.train.with.zero.coefficient.and.intercept.bed | awk '$2>=139247700 &&  $2<=139257500' | wc -l
50

```

and adjusted rate is `3106*10^{-7}=10^{-4}`. Those 50 windows are 1000 times higher than that in M0 for predicted rate. 

```
awk '{sum+=$4} END {print sum}' table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.A_to_C.and.mutation.T_to_G.ExpObsVar.even.window.as.train.with.zero.coefficient.and.intercept.bed
3922

awk '{sum+=$5} END {print sum}' table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.A_to_C.and.mutation.T_to_G.ExpObsVar.even.window.as.train.with.zero.coefficient.and.intercept.bed
1.2627

> 3922/1.2627
[1] 3106.043

```


```{r, echo=F, message=F, warning=F, cache=T, eval=F}
path="C:/Shengtong/Research/mutation-rate/ObsvsExp.10m.window"
mutation.type=unique(as.character(read.table("C:/Shengtong/Research/mutation-rate/mutation-rate-modeling/data/post.predictive.density/post.pred.for.model.txt", header=T)$mutation.type)) # get mutation types 
Train=c("odd", "even")
figures=list(); fig=0
m0.m2.exp.obs.list=list()
m0.exp.obs.total=tibble(obs=rep(0, 22), exp=rep(0,22)) # store total count across all mutation types 
m2.exp.obs.total=tibble(obs=rep(0, 22), exp=rep(0, 22))
#for (mut in 1:length(mutation.type))
#   for (set in 1:length(Train))
   {
      mut=1; set=1
      cat(mutation.type[mut], "is running", "\n")
      m2.exp.obs=as_tibble(read.table(paste(path, "/", "table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_", mutation.type[mut], ".ExpObsVar.", Train[set], ".window.as.train.bed.bed.added.10m", sep=""), header=F))
      
m0.exp.obs=as_tibble(read.table(paste(path, "/", "table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_", mutation.type[mut], ".ExpObsVar.", Train[set], ".window.as.train.with.zero.coefficient.and.intercept.bed.bed.added.10m", sep=""), header=F))
colnames(m2.exp.obs)=c("chr", "start", "end", "obs", "exp")
colnames(m0.exp.obs)=c("chr", "start", "end", "obs", "exp")


#########################

m0.m2.exp.obs=rbind(m0.exp.obs, m2.exp.obs) %>% add_column(model=c(rep("M0", nrow(m0.exp.obs)), rep("M2", nrow(m2.exp.obs))))  # combine two models together 

m0.m2.exp.obs.tidy=tibble(obs=as.numeric(as.character(m0.m2.exp.obs$obs)), exp=as.numeric(as.character(m0.m2.exp.obs$exp)), model=m0.m2.exp.obs$model) %>%drop_na() # convert obs, exp as factor into numeric vectors to draw the plot

fig=fig+1
m0.m2.exp.obs.list[[fig]]=m0.m2.exp.obs
i=fig
#x.limit=y.limit=max(m0.m2.exp.obs.list[[i]][,4:5])
figures[[fig]]=
   
   
   ggplot(m0.m2.exp.obs.tidy, aes(x=exp, y=obs, color=model)) +
  geom_point()+
#   xlim(c(0, 10))+
#+ylim(c(0, y.limit))+
   geom_abline(intercept = 0, slope = 1)+
   ggtitle(paste(mutation.type[ceiling(i/2)]))+
   theme(plot.title = element_text(hjust = 0.5, size=7)) # center the title

}# end of for (set in 1:length(Train))

colnames(m0.exp.obs.total)=c("obs", "exp")
colnames(m2.exp.obs.total)=c("obs", "exp")
######## save and output the results 
#write.table(m0.exp.obs.total, file=paste(path, "/","m0.exp.obs.total.txt", sep=""))
#write.table(m2.exp.obs.total, file=paste(path, "/","m2.exp.obs.total.txt", sep=""))
#save(m0.m2.exp.obs.chr.list, file=paste(path, "/", "m0.m2.exp.obs.chr.list.RData", sep=""))
```


* verify calculation of  predicted rate 

```
> load("table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.A_to_C.and.mutation.T_to_G.100bpwindow.ev> .line.train.model.RData")
>
> ls()
[1] "result"
> result
$para.est
                                          (Intercept)
                                          7.946130900
      second.cate.matrix[, 3:(2 + feature_number)]DHS
                                          0.111412210
second.cate.matrix[, 3:(2 + feature_number)]CpGisland
                                         -0.061066892
    second.cate.matrix[, 3:(2 + feature_number)]Lamin
                                          0.049454107
       second.cate.matrix[, 3:(2 + feature_number)]GC
                                         -0.051563344
       second.cate.matrix[, 3:(2 + feature_number)]RT
                                          0.099047740
       second.cate.matrix[, 3:(2 + feature_number)]RR
                                          0.072775740
     second.cate.matrix[, 3:(2 + feature_number)]Exon
                                          0.033057750
  second.cate.matrix[, 3:(2 + feature_number)]H3K27ac
                                         -0.006163996
 second.cate.matrix[, 3:(2 + feature_number)]H3K27me3
                                          0.005764340
 second.cate.matrix[, 3:(2 + feature_number)]H3K36me3
                                          0.044806480
  second.cate.matrix[, 3:(2 + feature_number)]H3K4me1
                                          0.041314267
  second.cate.matrix[, 3:(2 + feature_number)]H3K4me3
                                          0.094146882
   second.cate.matrix[, 3:(2 + feature_number)]H3K9ac
                                          0.006397160
  second.cate.matrix[, 3:(2 + feature_number)]H3K9me3
                                          0.096692925

```

```{r, echo=T}
coff.est=c(7.946130900, 0.111412210, -0.061066892,  0.049454107, -0.051563344, 0.099047740, 0.072775740, 0.033057750, -0.006163996, 0.005764340,0.044806480, 0.041314267, 0.094146882, 0.006397160, 0.096692925)
cova.fea.a2c=c(0,5.8508268e-08,0,0,1,0.41,0,108.804,0,0,1,0,0,0,0,1) # covariate feature for window chr8     139247700       139247800 for mutation A->C
cova.fea.t2g=c(0,4.1664681e-08,0,0,1,0.41,0,108.804,0,0,1,0,0,0,0,1)
#covariate feature for window chr8     139247700       139247800 for mutation T->G
feature_number=14
exp.rate=exp(cova.fea.a2c[3:(3+feature_number-1)]%*%coff.est[2:15]+coff.est[1])*(cova.fea.a2c[2]+cova.fea.t2g[2]) # this is expected rate
# covariate features are identical in both strands, but baseline rate should be added up in cauculating prediction rate  

cat("expected rate is", exp.rate, "\n") # which is exactly the one in file 
# awk '$5>0.5' table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.A_to_C.and.mutation.T_to_G.ExpObsVar.even.window.as.train.bed
#chr8 139247700 139247800 0 0.885879142920415 0.000179683336383749 3927.62074039213 -0.941211529317621 0.826701765213676

# what happens if replace 108.8 with average rate of 0.8 

cova.fea.a2c=c(0,5.8508268e-08,0,0,1,0.41,0,0.8,0,0,1,0,0,0,0,1) 
cova.fea.t2g=c(0,4.1664681e-08,0,0,1,0.41,0,0.8,0,0,1,0,0,0,0,1)
exp.rate=exp(cova.fea.a2c[3:(3+feature_number-1)]%*%coff.est[2:15]+coff.est[1])*(cova.fea.a2c[2]+cova.fea.t2g[2]) # this is expected rate
cat("after replace 108 with 0.8, expected rate is", exp.rate, "\n")
```

#### Chromosome wide scatter plot by combining all mutation types in M0, M2



```{r, echo=F, message=F, warning=F, cache=T, eval=F}

#* each dot is one chromosome by summing up across 100bp windows 
#* observed rate on y axis and expected on x axis 
#* expected rate in M0 is adjusted by scaling parameter L 



path="C:/Shengtong/Research/mutation-rate/ObsvsExp.10k.window"
mutation.type=unique(as.character(read.table("C:/Shengtong/Research/mutation-rate/mutation-rate-modeling/data/post.predictive.density/post.pred.for.model.txt", header=T)$mutation.type)) # get mutation types 
Train=c("odd", "even")
figures=list(); fig=0
m0.m2.exp.obs.chr.list=list()
m0.exp.obs.total=tibble(obs=rep(0, 22), exp=rep(0,22)) # store total count across all mutation types 
m2.exp.obs.total=tibble(obs=rep(0, 22), exp=rep(0, 22))
for (mut in 1:length(mutation.type))
   for (set in 1:length(Train))
   {
     # mut=1; set=1
      cat(mutation.type[mut], "is running", "\n")
      m2.exp.obs=as_tibble(read.table(paste(path, "/", "table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_", mutation.type[mut], ".ExpObsVar.", Train[set], ".window.as.train.bed.bed.added.10k", sep=""), header=F))
      
m0.exp.obs=as_tibble(read.table(paste(path, "/", "table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_", mutation.type[mut], ".ExpObsVar.", Train[set], ".window.as.train.with.zero.coefficient.and.intercept.bed.bed.added.10k", sep=""), header=F))
colnames(m2.exp.obs)=c("chr", "start", "end", "obs", "exp")
colnames(m0.exp.obs)=c("chr", "start", "end", "obs", "exp")

############### consider chromosome level analysis 
chr=unique(m2.exp.obs$chr)
m0.exp.obs.chr=tibble()
m2.exp.obs.chr=tibble()
for (cc in 1:22) #only look at chr1, chr2, ..., chr22
{
   
   m0.exp.obs.chr[cc,1]=sum(as.numeric(as.character(m0.exp.obs[which(m0.exp.obs$chr==chr[cc]),]$obs)), na.rm=T)
   m0.exp.obs.chr[cc,2]=sum(as.numeric(as.character(m0.exp.obs[which(m0.exp.obs$chr==chr[cc]),]$exp)), na.rm=T)
   
   m2.exp.obs.chr[cc,1]=sum(as.numeric(as.character(m2.exp.obs[which(m2.exp.obs$chr==chr[cc]),]$obs)), na.rm=T)
   m2.exp.obs.chr[cc,2]=sum(as.numeric(as.character(m2.exp.obs[which(m2.exp.obs$chr==chr[cc]),]$exp)), na.rm=T)
   
} # end of for (cc in 1:22)

colnames(m0.exp.obs.chr)=c("obs", "exp")
colnames(m2.exp.obs.chr)=c("obs", "exp")
#########################   sum over all mutation types 
m0.exp.obs.total=m0.exp.obs.total+m0.exp.obs.chr
m2.exp.obs.total=m2.exp.obs.total+m2.exp.obs.chr
#########################

m0.m2.exp.obs.chr=rbind(m0.exp.obs.chr, m2.exp.obs.chr) %>% add_column(model=c(rep("M0", nrow(m0.exp.obs.chr)), rep("M2", nrow(m2.exp.obs.chr))))  # combine two models together 

fig=fig+1
m0.m2.exp.obs.chr.list[[fig]]=m0.m2.exp.obs.chr
}# end of for (set in 1:length(Train))

colnames(m0.exp.obs.total)=c("obs", "exp")
colnames(m2.exp.obs.total)=c("obs", "exp")
######## save and output the results 
write.table(m0.exp.obs.total, file=paste(path, "/","m0.exp.obs.total.txt", sep=""))
write.table(m2.exp.obs.total, file=paste(path, "/","m2.exp.obs.total.txt", sep=""))
save(m0.m2.exp.obs.chr.list, file=paste(path, "/", "m0.m2.exp.obs.chr.list.RData", sep=""))
```


```{r, echo=F, warning=F, message=F}
path="C:/Shengtong/Research/mutation-rate/ObsvsExp.10k.window"
mutation.type=unique(as.character(read.table("C:/Shengtong/Research/mutation-rate/mutation-rate-modeling/data/post.predictive.density/post.pred.for.model.txt", header=T)$mutation.type)) # get mutation types 
load(paste(path, "/", "m0.m2.exp.obs.chr.list.RData", sep=""))
figures=list()
for (i in 1:length(m0.m2.exp.obs.chr.list))
{
   x.limit=y.limit=max(m0.m2.exp.obs.chr.list[[i]][,1:2])
   scale.para=sum(m0.m2.exp.obs.chr.list[[i]]$obs[1:22])/sum(m0.m2.exp.obs.chr.list[[i]]$exp[1:22]) # in M0, use scale parameter to adjust the expected rate 
   m0.m2.exp.obs.chr.list[[i]]$exp[1:22]=m0.m2.exp.obs.chr.list[[i]]$exp[1:22]*scale.para
   
   
figures[[i]]=ggplot(m0.m2.exp.obs.chr.list[[i]], aes(x=exp, y=obs, color=model)) +
  geom_point()+
   xlim(c(0, x.limit))+ylim(c(0, y.limit))+
   geom_abline(intercept = 0, slope = 1)+
   ggtitle(paste(mutation.type[ceiling(i/2)]))+
   theme(plot.title = element_text(hjust = 0.5, size=10)) # center the title
   
}    
```



```{r, echo=F, warning=F, message=F, eval=F}
#* scatter plot for odd windows 
figures[[1]]
figures[[3]]
figures[[5]]
figures[[7]]
figures[[9]]
figures[[11]]
figures[[13]]
figures[[15]]
figures[[17]]
```



```{r, echo=F, warning=F, message=F, eval=F}
#* scatter plot for even  windows
figures[[2]]
figures[[4]]
figures[[6]]
figures[[8]]
figures[[10]]
figures[[12]]
figures[[14]]
figures[[16]]
figures[[18]]
#figure=ggarrange(figures[[1]],figures[[3]], figures[[5]], figures[[7]], figures[[9]], figures[11], figures[[13]], figures[[15]], figures[[17]],  common.legend = TRUE, legend="right") 
#figure
#annotate_figure(figure,
#                top = text_grob("odd windows", color = "red", face = "bold", size = 14),
#                bottom = text_grob("Data source: \n ToothGrowth data set", color = "blue",
#                                   hjust = 1, x = 1, face = "italic", size = 10),
#                left = text_grob("Tooth length", color = "green", rot = 90),
#                right = "I'm done, thanks :-)!",
#                fig.lab = "Figure 1", fig.lab.face = "bold"
#)


#figure=ggarrange(figures[[2]],figures[[4]], figures[[6]], figures[[8]], figures[[10]], figures[12], figures[[14]], figures[[16]], figures[[18]],  common.legend = TRUE, legend="right") 
#figure
#annotate_figure(figure,
#                top = text_grob("even windows", color = "red", face = "bold", size = 14),
#                bottom = text_grob("Data source: \n ToothGrowth data set", color = "blue",
#                                   hjust = 1, x = 1, face = "italic", size = 10),
#                left = text_grob("Tooth length", color = "green", rot = 90),
#                right = "I'm done, thanks :-)!",
#                fig.lab = "Figure 1", fig.lab.face = "bold"
#)
```



* each dot is one chromosome by summing up across 100bp windows 
* M0, M2 use odd(even) windows to estimate parameters, then calculate expected rate in the same odd(even) windows and sum up for each one of 9 mutation types. M1 use odd(even) windows for parameter estimation and calculate expected rate in the same window and add up. 
* M0, M2 sum over all mutation types, M1 runs directly on mutation type combined sample    
* observed rate on y axis and expected on x axis 



```{r, echo=F, message=F, warning=F}
path="C:/Shengtong/Research/mutation-rate/ObsvsExp.10k.window"
m1.exp.obs.odd=as_tibble(read.table(paste(path, "/", "table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.ExpObsVar.odd.window.as.train.bed.bed.added.10k", sep=""), header=F))
m1.exp.obs.even=as_tibble(read.table(paste(path, "/", "table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.ExpObsVar.even.window.as.train.bed.bed.added.10k", sep=""), header=F))
colnames(m1.exp.obs.odd)=c("chr", "start", "end", "obs", "exp")
colnames(m1.exp.obs.even)=c("chr", "start", "end", "obs", "exp")

chr=paste("chr", seq(1,22), sep="")
m1.exp.obs.chr=tibble()
for (cc in 1:22) #only look at chr1, chr2, ..., chr22
{   
   m1.exp.obs.chr[cc,1]=sum(as.numeric(as.character(m1.exp.obs.odd[which(m1.exp.obs.odd$chr==chr[cc]),]$obs)), na.rm=T)+sum(as.numeric(as.character(m1.exp.obs.even[which(m1.exp.obs.even$chr==chr[cc]),]$obs)), na.rm=T)
   m1.exp.obs.chr[cc,2]=sum(as.numeric(as.character(m1.exp.obs.odd[which(m1.exp.obs.odd$chr==chr[cc]),]$exp)), na.rm=T)+sum(as.numeric(as.character(m1.exp.obs.even[which(m1.exp.obs.even$chr==chr[cc]),]$exp)), na.rm=T)
   
} # end of for (cc in 1:22)

colnames(m1.exp.obs.chr)=c("obs", "exp")

####### read into previously save data 
m0.exp.obs.total=read.table(paste(path, "/","m0.exp.obs.total.txt", sep=""), header=T)
m0.exp.obs.total$exp=m0.exp.obs.total$exp*sum(m0.exp.obs.total$obs)/sum(m0.exp.obs.total$exp) # in M0, use scaled expected rate 
m2.exp.obs.total=read.table(paste(path, "/","m2.exp.obs.total.txt", sep=""), header=T)
m0.m1.m2.exp.obs=rbind(m0.exp.obs.total, m1.exp.obs.chr, m2.exp.obs.total) %>%add_column(model=c(rep("M0", 22), rep("M1", 22), rep("M2", 22)))

x.limit=y.limit=max(m0.m1.m2.exp.obs[,1:2])
ggplot(m0.m1.m2.exp.obs, aes(x=exp, y=obs, color=model)) +
  geom_point()+
   xlim(c(0, x.limit))+ylim(c(0, y.limit))+
   geom_abline(intercept = 0, slope = 1)+
   ggtitle("scatter plot of three models on every chromosome")+
   theme(plot.title = element_text(hjust = 0.5, size=10)) # center the title

################### calculate residuals 
```

* $MSE=\sum\frac{(obs-exp)^2}{22}$

```{r, echo=F, warning=F, message=F}
m0.m1.m2.exp.obs.mse=as_tibble(m0.m1.m2.exp.obs)%>%add_column(mse=(m0.m1.m2.exp.obs$obs-m0.m1.m2.exp.obs$exp)^2)
m0.mse=sum(m0.m1.m2.exp.obs.mse%>%filter(model=="M0")%>%select(mse)%>%pull)/22
m1.mse=sum(m0.m1.m2.exp.obs.mse%>%filter(model=="M1")%>%select(mse)%>%pull)/22
m2.mse=sum(m0.m1.m2.exp.obs.mse%>%filter(model=="M2")%>%select(mse)%>%pull)/22
m0.m1.m2.mse=tibble(mse=c(m0.mse, m1.mse, m2.mse), model=c("M0", "M1", "M2"))
ggplot(data=m0.m1.m2.mse, aes(x=model, y=mse)) +
   theme(axis.text.x = element_text(angle = 60, vjust = 0.5, size=10))+
theme(text = element_text(size=10))+
geom_bar(stat="identity", fill="blue")+
    ylab("MSE")+
   ggtitle("Chromosome wise MSE")+
  theme(plot.title = element_text(hjust = 0.5, size=10)) # center the title
```


## Windows with zero observed counts 

These windows are possibly repeated regions 

### 1Mb windows 


```
# total number of 1Mb windows 
wc -l pooled.mutation.type.data/table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.ExpObsVar.even.window.as.train.bed.bed.added.1m
3174 pooled.mutation.type.data/table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.ExpObsVar.even.window.as.train.bed.bed.added.1m

# total number of 1Mb windows with zero observed counts 
awk '$4==0' pooled.mutation.type.data/table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.ExpObsVar.even.window.as.train.bed.bed.added.1m | wc -l
196

# total number of 1Mb windows overlapping with repeated regions
bedtools intersect -a pooled.mutation.type.data/table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.ExpObsVar.even.window.as.train.bed.bed.added.1m -b /project2/xinhe/Shengtong/mutation_rate/human.genome/repeat.regions/repeat.region  -wa | awk '!seen[$0]++' | wc -l
2918

# total number of zero observed count 1Mb windows overlapping with repeated regions
bedtools intersect -a pooled.mutation.type.data/table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.ExpObsVar.even.window.as.train.bed.bed.added.1m.zero.observed.count.window  -b /project2/xinhe/Shengtong/mutation_rate/human.genome/repeat.regions/repeat.region  -wa | awk '!seen[$0]++' | wc -l
33

> fisher.test(matrix(c(33, 2918, 196, 3174), nrow=2))

	Fisher's Exact Test for Count Data

data:  matrix(c(33, 2918, 196, 3174), nrow = 2)
p-value < 2.2e-16
alternative hypothesis: true odds ratio is not equal to 1
95 percent confidence interval:
 0.1222485 0.2669226
sample estimates:
odds ratio 
 0.1831832

33/196 vs 2918/3174 No enrichment! 

```


### 10k windows 

```
wc -l pooled.mutation.type.data/table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.ExpObsVar.even.window.as.train.bed.bed.added.10k
310238 pooled.mutation.type.data/table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.ExpObsVar.even.window.as.train.bed.bed.added.10k

bedtools intersect -a pooled.mutation.type.data/table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.ExpObsVar.even.window.as.train.bed.bed.added.10k -b /project2/xinhe/Shengtong/mutation_rate/human.genome/repeat.regions/repeat.region  -wa | awk '!seen[$0]++' | wc -l
286336

wc -l pooled.mutation.type.data/table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.ExpObsVar.even.window.as.train.bed.bed.added.10k.zero.observed.count.window
237327 pooled.mutation.type.data/table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.ExpObsVar.even.window.as.train.bed.bed.added.10k.zero.observed.count.window

bedtools intersect -a pooled.mutation.type.data/table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_mutation.ExpObsVar.even.window.as.train.bed.bed.added.10k.zero.observed.count.window  -b /project2/xinhe/Shengtong/mutation_rate/human.genome/repeat.regions/repeat.region  -wa | awk '!seen[$0]++' | wc -l
217849

> fisher.test(matrix(c(217849, 286336, 237327, 310238), nrow=2))

	Fisher's Exact Test for Count Data

data:  matrix(c(217849, 286336, 237327, 310238), nrow = 2)
p-value = 0.1655
alternative hypothesis: true odds ratio is not equal to 1
95 percent confidence interval:
 0.9868993 1.0022504
sample estimates:
odds ratio 
 0.9945515

No enrichment! 

```


## Parameter estimate in M1 & M2

### M1 vs M2

* three continuous variables are firstly standardized, then converted into binary variable before collapsing in both M1 and M2 model

* estimate in M1 is more robust than M2 in the sense that both odd and even windows produce similar estimates, but they could vary a lot across specific mutation types in M2 
* `combine` highlighted by dashed horizontal lines denotes M1 model for pooled mutation types vs other 9 mutation types in M2 model on x axis 

* vertical lines are 95% confidence interval. Clearly and as ecpected, CI in specific mutation types are much wider than that in `combine` sample. 

```{r, echo=F, warning=F, message=F}
path="C:\\Shengtong\\Research\\mutation-rate\\parameter_estimate\\Simons\\100bpwindow\\"
cova=c("DHS", "CpGisland", "Lamin", "GC", "RT", "RR", "Exon", "H3K27ac", "H3K27me3", "H3K36me3", "H3K4me1","H3K4me3","H3K9ac", "H3K9me3")
parameter.estimate.odd.window=list(); parameter.estimate.even.window=list()
for (mut in 1:length(mutation.type))
{
#   mut=1
   parameter.estimate.odd.window[[mut]]=loadRData(paste(path, "table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_", mutation.type[mut], ".100bpwindow.odd.line.train.model.with.standardize.covariate.RData", sep=""))
   parameter.estimate.even.window[[mut]]=loadRData(paste(path, "table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_", mutation.type[mut], ".100bpwindow.even.line.train.model.with.standardize.covariate.RData", sep=""))
} # end of for (mut in 1:length(mutation.type))

### this is parameter estimate in M1 
parameter.estimate.odd.window[[mut+1]]=loadRData(paste(path, "table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_", "mutation", ".100bpwindow.odd.line.train.model.with.standardize.covariate.RData", sep=""))
parameter.estimate.even.window[[mut+1]]=loadRData(paste(path, "table.ASCWGS_20180504.WGS1902_hg19_controls_SNV_remove_recurrent_", "mutation", ".100bpwindow.even.line.train.model.with.standardize.covariate.RData", sep=""))

figures=list(); parameter.estimate.cova.all=tibble()
for (i in 1:length(cova))  # for covariate feature i
{
   #i=1 for each covariate feature, compare parameter estimate across various mutation types 
   parameter.estimate.cova.odd=numeric();parameter.estimate.cova.odd.lower.bound=numeric(); parameter.estimate.cova.odd.upper.bound=numeric()
   parameter.estimate.cova.even=numeric();  parameter.estimate.cova.even.lower.bound=numeric(); parameter.estimate.cova.even.upper.bound=numeric()
   
   for (j in 1:(length(mutation.type)+1)) # for mutation type j 
      {
       parameter.estimate.cova.odd[j]=parameter.estimate.odd.window[[j]]$para.est[i+1]
       parameter.estimate.cova.odd.lower.bound[j]=parameter.estimate.odd.window[[j]]$para.conf[(i+1),1] # lower bound 
       parameter.estimate.cova.odd.upper.bound[j]=parameter.estimate.odd.window[[j]]$para.conf[(i+1),2] # upper bound 
       
       parameter.estimate.cova.even[j]=parameter.estimate.even.window[[j]]$para.est[i+1]
       parameter.estimate.cova.even.lower.bound[j]=parameter.estimate.even.window[[j]]$para.conf[(i+1),1] # lower bound 
       parameter.estimate.cova.even.upper.bound[j]=parameter.estimate.even.window[[j]]$para.conf[(i+1),2] # upper bound 
   }
   parameter.estimate.cova=tibble(estimate=c(parameter.estimate.cova.odd, parameter.estimate.cova.even), lower=c(parameter.estimate.cova.odd.lower.bound, parameter.estimate.cova.even.lower.bound), upper=c(parameter.estimate.cova.odd.upper.bound, parameter.estimate.cova.even.upper.bound),window=c(rep("odd", length(parameter.estimate.cova.odd)), rep("even", length(parameter.estimate.cova.even))), subtype=rep(c(mutation.type, "combine"),2)) # combine even and odd windows 
   parameter.estimate.cova$subtype=parameter.estimate.cova$subtype %>% recode( mutation.C_to_A.CpG.and.mutation.G_to_T.CpG="C_to_A.CpG", mutation.C_to_G.CpG.and.mutation.G_to_C.CpG="C_to_G.CpG", mutation.C_to_T.CpG.and.mutation.G_to_A.CpG="C_to_T.CpG", mutation.C_to_A.nonCpG.and.mutation.G_to_T.nonCpG="C_to_A.nonCpG",        mutation.C_to_G.nonCpG.and.mutation.G_to_C.nonCpG="C_to_G.noncpG,", mutation.C_to_T.nonCpG.and.mutation.G_to_A.nonCpG="C_to_T.nonCpG",                       mutation.A_to_C.and.mutation.T_to_G="A_to_C",  mutation.A_to_G.and.mutation.T_to_C="A_to_G", mutation.A_to_T.and.mutation.T_to_A="A_to_T") # rename mutation type to make them shorter 
   
parameter.estimate.cova.all=rbind(parameter.estimate.cova.all, parameter.estimate.cova)
   
############  plot parameter estimate for each individual covariate feature 
figures[[i]]=ggplot(data=parameter.estimate.cova, aes(x=subtype, y=estimate, fill=window)) +
   theme(axis.text.x = element_text(angle = 60, vjust = 0.5, size=10))+
theme(text = element_text(size=10))+
geom_bar(stat="identity", position=position_dodge())+
    ylab(expression(paste(hat(beta))))+xlab("")+
   geom_hline(yintercept=parameter.estimate.cova%>%filter(subtype=="combine"& window=="odd")%>%select(estimate)%>%pull, linetype="dashed", 
                color = "lightskyblue", size=1)+
   geom_hline(yintercept=parameter.estimate.cova%>%filter(subtype=="combine"& window=="even")%>%select(estimate)%>%pull, linetype="dashed", 
                color = "red", size=1)+  # use horizontal line to highlight
    geom_errorbar(aes(ymin=lower, ymax=upper),
                  width=.2,                    # Width of the error bars
                  position=position_dodge(.9))+
   ggtitle(paste(cova[i]))+
  theme(plot.title = element_text(hjust = 0.5, size=10)) # center the title

} # end of for (i in 1:length(cova))
parameter.estimate.cova.all=parameter.estimate.cova.all%>%add_column(cova=rep(cova, each=20))
############# use facet to plot all covariates in one panel 
#ggplot(data=parameter.estimate.cova.all, aes(x=subtype, y=estimate, fill=window)) +
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size=5))+
#   facet_grid(rows = vars(cova))+
#theme(text = element_text(size=10))+
#geom_bar(stat="identity", position=position_dodge())+
#    ylab("parameter estimate")+
#   geom_hline(yintercept=parameter.estimate.cova%>%filter(subtype=="combine"& window=="odd")%>%select(estimate)%>%pull, linetype="dashed", 
#                color = "lightskyblue")+
#   geom_hline(yintercept=parameter.estimate.cova%>%filter(subtype=="combine"& window=="even")%>%select(estimate)%>%pull, linetype="dashed", 
#                color = "red")#+  # use horizental line to highlight 
############# plot individual feature 
figures[[1]]
figures[[2]]
figures[[3]]
figures[[4]]
figures[[5]]
figures[[6]]
figures[[7]]
figures[[8]]
figures[[9]]
figures[[10]]
figures[[11]]
figures[[12]]
figures[[13]]
figures[[14]]
```

### Parameter estimate in M1 

* three continuous variables are firstly standardized, then converted into binary variable before collapsing 
* vertical lines are 95% confidence interval 

```{r, echo=F, message=F, warning=F}
parameter.estimate.even.window.model1=tibble(estimate=parameter.estimate.even.window[[mut+1]]$para.est, lower=parameter.estimate.even.window[[mut+1]]$para.conf[,1], upper=parameter.estimate.even.window[[mut+1]]$para.conf[,2])

parameter.estimate.odd.window.model1=tibble(estimate=parameter.estimate.odd.window[[mut+1]]$para.est, lower=parameter.estimate.odd.window[[mut+1]]$para.conf[,1], upper=parameter.estimate.odd.window[[mut+1]]$para.conf[,2])

parameter.estimate.model1=rbind(parameter.estimate.even.window.model1[2:15,], parameter.estimate.odd.window.model1[2:15,]) %>% add_column(window=c(rep("even",14), rep("odd", 14)), cova=rep(cova,2))


# Use 95% confidence intervals 
ggplot(parameter.estimate.model1, aes(x=cova, y=estimate, fill=window)) + 
    geom_bar(position=position_dodge(), stat="identity") +
   theme(axis.text.x = element_text(angle = 60, vjust = 0.5, size=10))+
theme(text = element_text(size=10))+
   ylab(expression(paste(hat(beta))))+xlab("covariate features")+
    geom_errorbar(aes(ymin=lower, ymax=upper),
                  width=.2,                    # Width of the error bars
                  position=position_dodge(.9))+
    ggtitle("Parameter estimate in M1")+
   theme(plot.title = element_text(hjust = 0.5, size=15)) # center the title
```

## Referecnce 

[Genomic Patterns of De Novo Mutation in Simplex Autism](https://pubmed.ncbi.nlm.nih.gov/28965761/), cell, 2017
